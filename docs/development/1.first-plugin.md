---
title: 第一个插件
---

# 第一个插件

## 认识插件：函数式插件

**最简单的 IPE 的插件，就是一个接受依赖注入的普通函数。**

```js
function myPlugin(ctx) {
  console.log('hello, world', ctx)
}
```

然后，让我们加载这个插件：

```js
function myPlugin(ctx) {
  console.log('hello, world', ctx)
}
ipe.plugin(myPlugin) // [!code focus]
```

你可以亲自尝试一下，打开你的浏览器控制台（F12），粘贴上面的代码，按下回车键。

就是这么简单，当你加载这个插件后，立刻就能在控制台看到 `hello, world` 字样。

## 让我们做些什么

为了更好的理解 IPE 的插件机制，我们让这个插件做点事情：

```js
function myButtonPlugin(ctx) {
  ctx.toolbox.addButton({
    id: 'my-first-plugin',
    icon: '👋',
    tooltip: 'My First Plugin',
    onClick: () => {
      alert('hello, world')
    },
  })
}
ipe.plugin(myButtonPlugin)
```

看看页面右下角的工具盒，是不是多了一个按钮？点击它，你会看到一个弹窗，上面写着 `hello, world`。

真不赖，我们的插件看上去离“快速编辑”也不远嘛！

但是控制台中有一些警告：

```
Error: property toolbox is not registered, declare it as `inject` to suppress this warning
```

别紧张，这是因为我们没有在插件中注入 `toolbox` 服务。

## 依赖注入

为了解决这个问题，我们需要在插件中注入 `toolbox` 服务。

```js
function myButtonPlugin(ctx) {
  // [!code ++]
  ctx.inject(['toolbox'], (ctx) => {
    ctx.toolbox.addButton({
      id: 'my-first-plugin',
      icon: '👋',
      tooltip: 'My First Plugin',
      onClick: () => {
        alert('hello, world')
      },
    })
  }) // [!code ++]
}
```

现在没有报错了！但是，为什么要这样做？

因为 `ctx.toolbox` 其实是由另外一个插件提供的服务，它的加载时机是不确定的。人总有运气差的时候，万一咱们的`myButtonPlugin`安装时`toolbox`还没有加载，那你就只能望 `undefined` 而兴叹了。

而通过 `ctx.inject`，IPE会确保你在插件中拿到的上下文，一定包含了 `toolbox` 服务。

## 更清晰的定义归纳：对象式插件

不过总是`ctx.inject`有时候会导致难以阅读，所以我们可以换用对象式插件：

<!-- prettier-ignore -->
```js
function myButtonPlugin(ctx) {       // [!code --]
  ctx.inject(['toolbox'], (ctx) => { // [!code --]
const myButtonPlugin = {             // [!code ++]
  inject: ['toolbox'],               // [!code ++]
  apply(ctx) {                       // [!code ++]
    ctx.toolbox.addButton({
      id: 'my-first-plugin',
      icon: '👋',
      tooltip: 'My First Plugin',
      onClick: () => {
        alert('hello, world')
      },
    })
  },                                 // [!code ++]
}
ipe.plugin(myButtonPlugin)
```

现在你学会了第二种插件的写法：**IPE 插件可以是一个包含 `apply` 方法的对象。**

- `apply` 的参数是依赖注入后的上下文，你可以在这个上下文中访问所有服务。

可选的属性：

- `name` 属性来传递插件的名称。
- `inject` 属性来传递服务列表。

## 清理副作用

IPE 的插件都是可热插拔的，这意味着你也许需要手动清理副作用。

什么是副作用？副作用是指插件在启动后，产生的一些不可逆的影响。

比如，我们的插件在工具盒中添加了一个按钮，插件卸载之后它依然存在，而且点击它之后有可能会搞出报错。这就是一种副作用。

那么作为负责任的开发者，我们需要在插件卸载时移除这个按钮：

<!-- prettier-ignore -->
```js
const myButtonPlugin = {
  inject: ['toolbox'],
  apply(ctx) {
    ctx.toolbox.addButton({
      id: 'my-first-plugin',
      icon: '👋',
      tooltip: 'My First Plugin',
      onClick: () => {
        alert('hello, world')
      },
    })

    ctx.on('dispose', () => {                     // [!code ++]
      ctx.toolbox.removeButton('my-first-plugin') // [!code ++]
    })                                            // [!code ++]
  },
}
ipe.plugin(myButtonPlugin)
```

## 模块化的入门：类式插件

**IPE的插件可以是一个普通的类，它的 constructor 的第一个参数是所在的上下文，第二个参数是可能传入的配置项。**

```js
class MyButtonPlugin {
  static inject = ['toolbox']
  constructor(ctx, config) {
    ctx.toolbox.addButton({
      id: 'my-first-plugin',
      icon: '👋',
      tooltip: 'My First Plugin',
      onClick: () => {
        alert('hello, world')
      },
    })
  }
}
ipe.plugin(MyButtonPlugin)
```

这对于 TypeScript 用户来说非常友好，因为它可以让你使用装饰器来注册插件，我们会在后面的章节中介绍。

## 总结：插件的基本形式

一个插件需要是以下三种基本形式之一：

1. 一个接受两个参数的函数，第一个参数是所在的上下文，第二个参数是可能传入的配置项
2. 一个对象，其中的 apply 方法是第一种形式中所说的函数，包括可选的 `inject` 和 `name` 属性等
3. 一个接受两个参数的类，constructor 的第一个参数是所在的上下文，第二个参数是可能传入的配置项

```ts
ctx.plugin((ctx) => {
  // ...
})

ctx.plugin({
  apply: (ctx) => {
    // ...
  },
})

ctx.plugin(
  class {
    constructor(ctx) {
      // ...
    }
  }
)
```
